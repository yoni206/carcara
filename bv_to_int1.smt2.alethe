unsat
(
(assume a0 (= x #b0011))
(assume a1 (= y #b0011))
(assume a2 (not (bvsle (bvadd x y) #b0110)))
(assume a3 (= (bvadd x y) #b0110))
(step t0 (cl (not (= (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7) false)) (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7)) false) :rule equiv_pos2)
(step t1 (cl (not (= (= x #b0011) (= (ubv_to_int x) 3))) (not (= x #b0011)) (= (ubv_to_int x) 3)) :rule equiv_pos2)
(step t2 (cl (= (= x #b0011) (= (ubv_to_int x) 3))) :rule bv_intblast)
(step t3 (cl (= (ubv_to_int x) 3)) :rule resolution :premises (t1 t2 a0))
(step t4 (cl (not (= (= y #b0011) (= (ubv_to_int y) 3))) (not (= y #b0011)) (= (ubv_to_int y) 3)) :rule equiv_pos2)
(step t5 (cl (= (= y #b0011) (= (ubv_to_int y) 3))) :rule bv_intblast)
(step t6 (cl (= (ubv_to_int y) 3)) :rule resolution :premises (t4 t5 a1))
(step t7 (cl (= (+ (ubv_to_int x) (ubv_to_int y)) (+ 3 3))) :rule cong :premises (t3 t6))
(step t8 (cl (= 16 16)) :rule refl)
(step t9 (cl (= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (mod (+ 3 3) 16))) :rule cong :premises (t7 t8))
(step t10 (cl (= -1 -1)) :rule refl)
(step t11 (cl (= 8 8)) :rule refl)
(step t12 (cl (= (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) (>= (mod (+ 3 3) 16) 8))) :rule cong :premises (t9 t11))
(step t13 (cl (= 0 0)) :rule refl)
(step t14 (cl (= (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0) (ite (>= (mod (+ 3 3) 16) 8) 16 0))) :rule cong :premises (t12 t8 t13))
(step t15 (cl (= (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0)) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0)))) :rule cong :premises (t10 t14))
(step t16 (cl (= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) (+ (mod (+ 3 3) 16) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0))))) :rule cong :premises (t9 t15))
(step t17 (cl (= 7 7)) :rule refl)
(step t18 (cl (= (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7) (>= (+ (mod (+ 3 3) 16) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0))) 7))) :rule cong :premises (t16 t17))
(step t19 (cl (= (+ 3 3) 6)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (+ 3 3) 6) 3 7))
(step t20 (cl (= (mod (+ 3 3) 16) (mod 6 16))) :rule cong :premises (t19 t8))
(step t21 (cl (= (mod 6 16) 6)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (mod 6 16) 6) 3 7))
(step t22 (cl (= (mod (+ 3 3) 16) 6)) :rule trans :premises (t20 t21))
(step t23 (cl (= (>= (mod (+ 3 3) 16) 8) (>= 6 8))) :rule cong :premises (t22 t11))
(step t24 (cl (= (>= 6 8) false)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (>= 6 8) false) 3 7))
(step t25 (cl (= (>= (mod (+ 3 3) 16) 8) false)) :rule trans :premises (t23 t24))
(step t26 (cl (= (ite (>= (mod (+ 3 3) 16) 8) 16 0) (ite false 16 0))) :rule cong :premises (t25 t8 t13))
(step t27 (cl (= (ite false 16 0) 0)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (ite false 16 0) 0) 1 7))
(step t28 (cl (= (ite (>= (mod (+ 3 3) 16) 8) 16 0) 0)) :rule trans :premises (t26 t27))
(step t29 (cl (= (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0)) (* -1 0))) :rule cong :premises (t10 t28))
(step t30 (cl (= (* -1 0) 0)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (* -1 0) 0) 3 7))
(step t31 (cl (= (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0)) 0)) :rule trans :premises (t29 t30))
(step t32 (cl (= (+ (mod (+ 3 3) 16) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0))) (+ 6 0))) :rule cong :premises (t22 t31))
(step t33 (cl (= (+ 6 0) 6)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (+ 6 0) 6) 3 7))
(step t34 (cl (= (+ (mod (+ 3 3) 16) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0))) 6)) :rule trans :premises (t32 t33))
(step t35 (cl (= (>= (+ (mod (+ 3 3) 16) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0))) 7) (>= 6 7))) :rule cong :premises (t34 t17))
(step t36 (cl (= (>= 6 7) false)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (>= 6 7) false) 3 7))
(step t37 (cl (= (>= (+ (mod (+ 3 3) 16) (* -1 (ite (>= (mod (+ 3 3) 16) 8) 16 0))) 7) false)) :rule trans :premises (t35 t36))
(step t38 (cl (= (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7) false)) :rule trans :premises (t18 t37))
(step t39 (cl (not (= (not (bvsle (bvadd x y) #b0110)) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) (not (not (bvsle (bvadd x y) #b0110))) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7)) :rule equiv_pos2)
(step t40 (cl (= (bvsle (bvadd x y) #b0110) (not (bvslt #b0110 (bvadd x y))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (bvsle (bvadd x y) #b0110) (not (bvslt #b0110 (bvadd x y)))) 4 6))
(step t41 (cl (= (not (bvsle (bvadd x y) #b0110)) (not (not (bvslt #b0110 (bvadd x y)))))) :rule cong :premises (t40))
(step t42 (cl (= (not (not (bvslt #b0110 (bvadd x y)))) (bvslt #b0110 (bvadd x y)))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (not (not (bvslt #b0110 (bvadd x y)))) (bvslt #b0110 (bvadd x y))) 1 7))
(step t43 (cl (= (not (bvsle (bvadd x y) #b0110)) (bvslt #b0110 (bvadd x y)))) :rule trans :premises (t41 t42))
(step t44 (cl (= (bvslt #b0110 (bvadd x y)) (< (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))))) :rule bv_intblast)
(step t45 (cl (= (< (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))) (not (>= (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (< (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))) (not (>= (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))))) 3 6))
(step t46 (cl (= (- 6 (ite (< 6 8) 0 16)) (+ 6 (* -1 (ite (< 6 8) 0 16))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (- 6 (ite (< 6 8) 0 16)) (+ 6 (* -1 (ite (< 6 8) 0 16)))) 3 6))
(step t47 (cl (= 6 6)) :rule refl)
(step t48 (cl (= (< 6 8) true)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (< 6 8) true) 3 6))
(step t49 (cl (= (ite (< 6 8) 0 16) (ite true 0 16))) :rule cong :premises (t48 t13 t8))
(step t50 (cl (= (ite true 0 16) 0)) :rule hole :args ("TRUST_THEORY_REWRITE" (= (ite true 0 16) 0) 1 7))
(step t51 (cl (= (ite (< 6 8) 0 16) 0)) :rule trans :premises (t49 t50))
(step t52 (cl (= (* -1 (ite (< 6 8) 0 16)) (* -1 0))) :rule cong :premises (t10 t51))
(step t53 (cl (= (* -1 (ite (< 6 8) 0 16)) 0)) :rule trans :premises (t52 t30))
(step t54 (cl (= (+ 6 (* -1 (ite (< 6 8) 0 16))) (+ 6 0))) :rule cong :premises (t47 t53))
(step t55 (cl (= (+ 6 (* -1 (ite (< 6 8) 0 16))) 6)) :rule trans :premises (t54 t33))
(step t56 (cl (= (- 6 (ite (< 6 8) 0 16)) 6)) :rule trans :premises (t46 t55))
(step t57 (cl (= (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)) (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)) (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)))) 3 6))
(step t58 (cl (= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (mod (+ (ubv_to_int x) (ubv_to_int y)) 16))) :rule refl)
(step t59 (cl (= (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) (not (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8)))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) (not (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8))) 3 6))
(step t60 (cl (= (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16) (ite (not (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8)) 0 16))) :rule cong :premises (t59 t13 t8))
(step t61 (cl (= (ite (not (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8)) 0 16) (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (ite (not (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8)) 0 16) (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0)) 1 7))
(step t62 (cl (= (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16) (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) :rule trans :premises (t60 t61))
(step t63 (cl (= (* -1 (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0)))) :rule cong :premises (t10 t62))
(step t64 (cl (= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))) (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))))) :rule cong :premises (t58 t63))
(step t65 (cl (= (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)) (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))))) :rule trans :premises (t57 t64))
(step t66 (cl (= (>= (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))) (>= 6 (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0)))))) :rule cong :premises (t56 t65))
(step t67 (cl (= (>= 6 (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0)))) (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7)))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (>= 6 (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0)))) (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) 3 7))
(step t68 (cl (= (>= (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))) (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7)))) :rule trans :premises (t66 t67))
(step t69 (cl (= (not (>= (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)))) (not (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))))) :rule cong :premises (t68))
(step t70 (cl (= (not (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (not (not (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7)) 1 7))
(step t71 (cl (= (not (>= (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16)))) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) :rule trans :premises (t69 t70))
(step t72 (cl (= (< (- 6 (ite (< 6 8) 0 16)) (- (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (ite (< (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 0 16))) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) :rule trans :premises (t45 t71))
(step t73 (cl (= (not (bvsle (bvadd x y) #b0110)) (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7))) :rule trans :premises (t43 t44 t72))
(step t74 (cl (>= (+ (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) (* -1 (ite (>= (mod (+ (ubv_to_int x) (ubv_to_int y)) 16) 8) 16 0))) 7)) :rule resolution :premises (t39 t73 a2))
(step t75 (cl false) :rule resolution :premises (t0 t38 t74))
(step t76 (cl (not false)) :rule false)
(step t77 (cl) :rule resolution :premises (t75 t76))
)
